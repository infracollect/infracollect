//go:build ignore

// gen-cli-docs generates CLI command documentation by building the CLI binary
// and capturing the help output for each command.
package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/samber/lo"
)

type command struct {
	name string
	args []string
}

var commands = []command{
	{
		name: "infracollect",
		args: []string{"--help"},
	},
	{
		name: "collect",
		args: []string{"collect", "--help"},
	},
	{
		name: "version",
		args: []string{"version", "--help"},
	},
}

func main() {
	root, err := findProjectRoot()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error finding project root: %v\n", err)
		os.Exit(1)
	}

	outputDir := filepath.Join(root, "website", "src", "content", "docs", "reference")
	binPath := filepath.Join(root, "bin", "infracollect")

	// Build the CLI binary
	fmt.Println("Building CLI binary...")
	buildCmd := exec.Command("go", "build", "-o", binPath, "./cmd/infracollect")
	buildCmd.Dir = root
	buildCmd.Stderr = os.Stderr
	if err := buildCmd.Run(); err != nil {
		fmt.Fprintf(os.Stderr, "Error building CLI: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("Built CLI binary at %s\n", binPath)

	// Collect help output for all commands
	var sections []string
	for _, cmd := range commands {
		fmt.Printf("Capturing help for %s...\n", cmd.name)

		helpCmd := exec.Command(binPath, cmd.args...)
		output, err := helpCmd.Output()
		if err != nil {
			if exitErr, ok := err.(*exec.ExitError); ok {
				output = exitErr.Stderr
			} else {
				fmt.Fprintf(os.Stderr, "Error running %s: %v\n", cmd.name, err)
				continue
			}
		}

		sections = append(sections, formatSection(cmd.name, string(output)))
	}

	// Generate single markdown file
	markdown := generateMarkdown(sections)
	outputPath := filepath.Join(outputDir, "cli.md")

	if err := os.WriteFile(outputPath, []byte(markdown), 0o644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing %s: %v\n", outputPath, err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s\n", outputPath)
	fmt.Println("Done!")
}

func formatSection(name, helpOutput string) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("## %s\n\n", name))
	sb.WriteString("```text\n")
	sb.WriteString(strings.Join(lo.Map(strings.Split(strings.TrimSpace(helpOutput), "\n"), func(line string, _ int) string {
		return strings.TrimRight(line, " ")
	}), "\n"))
	sb.WriteString("\n```\n")

	return sb.String()
}

func generateMarkdown(sections []string) string {
	var sb strings.Builder

	sb.WriteString("---\n")
	sb.WriteString("title: CLI\n")
	sb.WriteString("description: Reference for the infracollect command-line interface.\n")
	sb.WriteString("---\n\n")

	sb.WriteString("<!-- This file is auto-generated by scripts/gen-cli-docs.go. Do not edit manually. -->\n\n")

	for i, section := range sections {
		sb.WriteString(section)
		if i < len(sections)-1 {
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

func findProjectRoot() (string, error) {
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}

	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}

		parent := filepath.Dir(dir)
		if parent == dir {
			return "", fmt.Errorf("go.mod not found")
		}
		dir = parent
	}
}
